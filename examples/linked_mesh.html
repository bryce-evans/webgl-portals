<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - transform controls</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script type="module" src="/modules/three.js/build/three.module.js"></script>

        <link rel="stylesheet" href="/examples/css/demo_base.css">
    </head>
    <body>

        <div id="info">
            "W" translate | "E" rotate | "R" scale | "+/-" adjust size<br />
            "Q" toggle world/local space |  "Shift" snap to grid<br />
            "X" toggle X | "Y" toggle Y | "Z" toggle Z | "Spacebar" toggle enabled<br />
            "C" toggle camera | "V" random zoom
        </div>

        <script type="module">

            import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';

            import { OrbitControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/OrbitControls.js';
            import { TransformControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/TransformControls.js';

            let cameraPersp, cameraOrtho, currentCamera;
            let scene, renderer, control, orbit, mesh, mesh2;

            init();
            render();

            function init() {

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.localClippingEnabled = true;
                document.body.appendChild( renderer.domElement );

                const aspect = window.innerWidth / window.innerHeight;

                cameraPersp = new THREE.PerspectiveCamera( 50, aspect, 1, 3000 );
                cameraOrtho = new THREE.OrthographicCamera( - 600 * aspect, 600 * aspect, 600, - 600, 0.01, 30000 );
                currentCamera = cameraPersp;

                currentCamera.position.set( 10, 5, 10 );
                currentCamera.lookAt( 0, 20, 0 );

                scene = new THREE.Scene();
                scene.add( new THREE.GridHelper( 10, 10, 0x888888, 0x444444 ) );

                var light = new THREE.DirectionalLight( 0xffffff, 1 );
                light.position.set( 1, 1, 1 );
                scene.add( light );

                light = new THREE.AmbientLight( 0x444444 );
                scene.add( light );


                const texture = new THREE.TextureLoader().load( '/examples/rsc/textures/uv_test_map.jpeg', render );

                orbit = new OrbitControls( currentCamera, renderer.domElement );
                orbit.update();
                orbit.addEventListener( 'change', render );

                control = new TransformControls( currentCamera, renderer.domElement );
                control.addEventListener( 'change', render );
                control.setSpace( 'local' );

                control.addEventListener( 'dragging-changed', function ( event ) {
                    orbit.enabled = !event.value;
                });

                // Assumes 
                function clip_from_mesh(mesh) {
                    const vert_data = mesh.geometry.attributes.position.array;
                    let pts = [];
                    for (let i = 0; i < vert_data.length; i += 3) {
                        let pt = new THREE.Vector3(vert_data[i], vert_data[i+1], vert_data[i+2]);
                        pt.applyMatrix4( mesh.matrix );
                        pts.push(pt);
                    }

                    const a = pts[0];
                    const b = pts[2];
                    const c = pts[1];
                    const ab = b.sub(a);
                    const ac = c.sub(a);
                    const cross = ab.cross(ac).normalize();
                    return new THREE.Plane(cross, -(a.x * cross.x + a.y * cross.y + a.z * cross.z));
                }

                const plane_geo = new THREE.PlaneGeometry( 3, 3 );
                const plane_mat = new THREE.MeshLambertMaterial( { color: 0x00aa88, side:THREE.DoubleSide } );
                
                // Meshes for portal.
                let plane = new THREE.Mesh( plane_geo, plane_mat );
                plane.rotation.y = - Math.PI / 6;
                plane.position.z = 1;
                plane.updateMatrix();
                scene.add( plane );

                // Mesh for second portal.
                let plane2 = new THREE.Mesh( plane_geo, plane_mat );
                plane2.rotation.y = Math.PI + Math.PI / 6;
                plane2.position.z = -5;
                plane2.updateMatrix();
                scene.add( plane2 );

                // Clipping planes from portals.
                const clip1 = clip_from_mesh(plane);
                const clip2 = clip_from_mesh(plane2);

                // Cube geometry.
                const geometry = new THREE.BoxBufferGeometry( 2, 2, 2 );

                // Main cube.
                const material = new THREE.MeshLambertMaterial( { map: texture, clippingPlanes: [clip1]} );
                mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );

                // Linked dummy cube.
                // const material2 = new THREE.MeshLambertMaterial( { map: texture, clippingPlanes: [clip2]} );
                const material2 = new THREE.MeshLambertMaterial( { map: texture });//  , clippingPlanes: [clip2]} );
                mesh2 = new THREE.Mesh( geometry, material2 );
                mesh2.position.z = -5;
                scene.add( mesh2 );

                control.attach( mesh2 );
                scene.add( control );

                window.THREE = THREE;
                window.scene = scene;
                window.mesh = mesh;
                window.mesh2 = mesh2;   
                window.plane = plane;
                window.plane2 = plane2;
                window.clip1 = clip1;
                window.clip2 = clip2;
                window.control = control;

                window.addEventListener( 'resize', onWindowResize, false );
                window.addEventListener( 'keydown', function ( event ) {

                    switch ( event.keyCode ) {
                        case 81: // Q
                            control.setSpace( control.space === "local" ? "world" : "local" );
                            break;

                        case 87: // W
                            control.setMode( "translate" );
                            break;

                        case 69: // E
                            control.setMode( "rotate" );
                            break;

                        case 82: // R
                            control.setMode( "scale" );
                            break;

                        case 67: // C
                            const position = currentCamera.position.clone();

                            currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
                            currentCamera.position.copy( position );

                            orbit.object = currentCamera;
                            control.camera = currentCamera;

                            currentCamera.lookAt( orbit.target.x, orbit.target.y, orbit.target.z );
                            onWindowResize();
                            break;

                        case 86: // V
                            const randomFoV = Math.random() + 0.1;
                            const randomZoom = Math.random() + 0.1;

                            cameraPersp.fov = randomFoV * 160;
                            cameraOrtho.bottom = - randomFoV * 500;
                            cameraOrtho.top = randomFoV * 500;

                            cameraPersp.zoom = randomZoom * 5;
                            cameraOrtho.zoom = randomZoom * 5;
                            onWindowResize();
                            break;

                        case 187:
                        case 107: // +, =, num+
                            control.setSize( control.size + 0.1 );
                            break;

                        case 189:
                        case 109: // -, _, num-
                            control.setSize( Math.max( control.size - 0.1, 0.1 ) );
                            break;

                        case 88: // X
                            control.showX = ! control.showX;
                            break;

                        case 89: // Y
                            control.showY = ! control.showY;
                            break;

                        case 90: // Z
                            control.showZ = ! control.showZ;
                            break;

                        case 32: // Spacebar
                            control.enabled = ! control.enabled;
                            break;
                    }
                } );
            }

            function onWindowResize() {

                const aspect = window.innerWidth / window.innerHeight;

                cameraPersp.aspect = aspect;
                cameraPersp.updateProjectionMatrix();

                cameraOrtho.left = cameraOrtho.bottom * aspect;
                cameraOrtho.right = cameraOrtho.top * aspect;
                cameraOrtho.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                render();
            }

            function render() {
                if (window.mesh) {
                    let plane = window.plane;
                    let plane2 = window.plane2;
                    let mesh = window.mesh;
                    let mesh2 = window.mesh2;

                    mesh.matrixAutoUpdate  = false;
				
					var portal_to_origin = new THREE.Matrix4();
					portal_to_origin.multiplyMatrices(plane2.matrixWorld.invert(), mesh2.matrixWorld);

					var flip_xz = new THREE.Matrix4().identity();
					flip_xz.elements[0] *= -1;
					flip_xz.elements[10] *= -1;

					// mesh.matrix.multiplyMatrices(portal_to_origin, origin_to_portal2);
                    // let relative_to_out = new THREE.Matrix4();
                    // relative_to_out.multiplyMatrices(portal_to_origin, mesh.matrix);

					mesh.matrix.multiplyMatrices(flip_xz, portal_to_origin);
                    mesh.matrix.multiplyMatrices(plane.matrixWorld.invert(), mesh.matrix);

					
					// Mesh.position isn't used when we turn auto-update to false.
					// If we want to keep it current, we need to manually set it from the matrix.
					mesh.position.setFromMatrixPosition(mesh.matrix);
                    mesh.matrixWorldNeedsUpdate = true;



    //                 mesh2.matrixAutoUpdate = false;
                
    //                 // const in_port_to_origin = plane.matrixWorld.invert();
    //                 // const obj_relative_to_in_port = in_port_to_origin.multiply()

    //                 let mesh_relative_to_in_port = new THREE.Matrix4();
    //                 mesh_relative_to_in_port.multiplyMatrices(plane.matrixWorld.invert(), mesh.matrixWorld);

    //                 // The front face of the portal mesh is where objects come in and go out.
    //                 // Therefore, for an object to go the same direction and skip a gap, the portal is rotated 180deg.
    //                 // x-> O     O x-> 
            

    //                 // Transforms to handle "in-out" behavior. For object going into A and out B:
    //                 // Flip Z: As you go in A, you come out B
    //                 // Flip X: Required to maintain right-hand rule.    
                    
    // //                           A                  B
    // //                               (+Y)    (+Y)
    // //                                 |      |
    // //                                 |      |
    // //                                 |      |
    // //  OBJECT ->         (+Z) - - - - o      o - - - - (+Z)        -> OBJECT
    // //                                /        \
    // //                               /          \
    // //                            (+X)          (-X)

                    
    //                 let flip_xz = new THREE.Matrix4().identity();
    //                 flip_xz.elements[0] *= -1;
    //                 flip_xz.elements[10] *= -1;

    //                 // flip_xz.multiply(portal_to_origin);
    //                 // mesh2.matrix.set(flip_xz);
                    

    //                 // flip_xz.multiply(portal_to_origin);

    //                 // mesh2.matrixWorld.multiply(portal_to_origin);
    //                 // mesh2.matrixWorld.multiply(flip_xz);
                    
    //                 let relative_transform = new THREE.Matrix4().multiplyMatrices(flip_xz, mesh_relative_to_in_port);
    //                 // flip it back
    //                 // relative_transform.multiplyMatrices(relative_transform, flip_xz);
    //                 mesh2.matrix.multiplyMatrices( relative_transform, plane2.matrix);
                    
    //                 // Mesh.position isn't used when we turn auto-update to false.
    //                 // If we want to keep it current, we need to manually set it from the matrix.
    //                 mesh2.position.setFromMatrixPosition(mesh2.matrix);

    //                 // var out_of_portal = mesh.position.dot(clip1.normal) + clip1.constant > 0;
    //                 // Mesh is considered inside the portal now, so we need to swap places with the dummy.
    //                 // if (!out_of_portal) {
    //                 //     [mesh.matrix, mesh2.matrix] = [mesh2.matrix, mesh.matrix];
    //                 //     mesh.position.setFromMatrixPosition(mesh.matrix);
    //                 //     mesh2.position.setFromMatrixPosition(mesh2.matrix);
    //                 // }

    //                 //out_of_portal = mesh2.position.dot(clip2.normal) + clip2.constant >= 0;
    //                 // control2.visible = out_of_portal;

    //                 mesh2.matrixWorldNeedsUpdate = true;
                }

                renderer.render( scene, currentCamera );

            }
            window.render = render;

        </script>
    </body>
</html>
