<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - transform controls</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script type="module" src="/modules/three.js/build/three.module.js"></script>

        <link rel="stylesheet" href="/examples/css/demo_base.css">
    </head>
    <body>

        <div id="info">
            "W" translate | "E" rotate | "R" scale | "+/-" adjust size<br />
            "Q" toggle world/local space |  "Shift" snap to grid<br />
            "X" toggle X | "Y" toggle Y | "Z" toggle Z | "Spacebar" toggle enabled<br />
            "C" toggle camera | "V" random zoom
        </div>

        <script type="module">

            import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';

            import { OrbitControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/OrbitControls.js';
            import { TransformControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/TransformControls.js';

            let cameraPersp, cameraOrtho, currentCamera;
            let scene, renderer, control, orbit, mesh, mesh2;

            init();
            render();

            function init() {

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.localClippingEnabled = true;
                document.body.appendChild( renderer.domElement );

                const aspect = window.innerWidth / window.innerHeight;

                cameraPersp = new THREE.PerspectiveCamera( 50, aspect, 1, 3000 );
                cameraOrtho = new THREE.OrthographicCamera( - 600 * aspect, 600 * aspect, 600, - 600, 0.01, 30000 );
                currentCamera = cameraPersp;

                currentCamera.position.set( 7, 11, 7 );
                currentCamera.lookAt( 0, 20, 0 );

                scene = new THREE.Scene();
                scene.add( new THREE.GridHelper( 10, 10, 0x888888, 0x444444 ) );

                var light = new THREE.DirectionalLight( 0xffffff, 1 );
                light.position.set( 1, 1, 1 );
                scene.add( light );

                light = new THREE.AmbientLight( 0x444444 );
                scene.add( light );


                const texture = new THREE.TextureLoader().load( '/examples/rsc/textures/uv_test_map.jpeg', render );

                orbit = new OrbitControls( currentCamera, renderer.domElement );
                orbit.update();
                orbit.addEventListener( 'change', render );

                control = new TransformControls( currentCamera, renderer.domElement );
                control.addEventListener( 'change', render );
                control.setSpace( 'local' );

                control.addEventListener( 'dragging-changed', function ( event ) {
                    orbit.enabled = !event.value;
                });

                // Assumes 
                function clip_from_mesh(mesh) {
                    const vert_data = mesh.geometry.attributes.position.array;
                    let pts = [];
                    for (let i = 0; i < vert_data.length; i += 3) {
                        let pt = new THREE.Vector3(vert_data[i], vert_data[i+1], vert_data[i+2]);
                        pt.applyMatrix4( mesh.matrix );
                        pts.push(pt);
                    }

                    const a = pts[0];
                    const b = pts[2];
                    const c = pts[1];
                    const ab = b.sub(a);
                    const ac = c.sub(a);
                    const cross = ab.cross(ac).normalize();
                    return new THREE.Plane(cross, -(a.x * cross.x + a.y * cross.y + a.z * cross.z));
                }

                const plane_geo = new THREE.PlaneGeometry( 3, 3 );
                const plane_mat = new THREE.MeshLambertMaterial( { color: 0x00aa88, side:THREE.DoubleSide } );
                
                // Meshes for portal.
                let plane = new THREE.Mesh( plane_geo, plane_mat );
                plane.rotation.y = - Math.PI / 6;
                plane.position.z = 1;
                plane.updateMatrix();
                scene.add( plane );

                // Mesh for second portal.
                let plane2 = new THREE.Mesh( plane_geo, plane_mat );
                plane2.rotation.y = 2 * Math.PI / 6;
                plane2.position.z = -5;
                plane2.updateMatrix();
                scene.add( plane2 );

                // Clipping planes from portals.
                const clip1 = clip_from_mesh(plane);
                const clip2 = clip_from_mesh(plane2);

                // Cube geometry.
                const geometry = new THREE.BoxBufferGeometry( 2, 2, 2 );

                // Main cube.
                const material = new THREE.MeshLambertMaterial( { map: texture, clippingPlanes: [clip1]} );
                mesh = new THREE.Mesh( geometry, material );
                mesh.position.z = 1;
                scene.add( mesh );

                // Linked dummy cube.
                const material2 = new THREE.MeshLambertMaterial( { map: texture, clippingPlanes: [clip2]} );
                // const material2 = new THREE.MeshLambertMaterial( { map: texture });//  , clippingPlanes: [clip2]} );
                mesh2 = new THREE.Mesh( geometry, material2 );

                scene.add( mesh2 );

                control.attach( mesh );
                scene.add( control );

                window.THREE = THREE;
                window.scene = scene;
                window.mesh = mesh;
                window.mesh2 = mesh2;   
                window.plane = plane;
                window.plane2 = plane2;
                window.clip1 = clip1;
                window.clip2 = clip2;
                window.control = control;

                window.addEventListener( 'resize', onWindowResize, false );
                window.addEventListener( 'keydown', function ( event ) {

                    switch ( event.keyCode ) {
                        case 81: // Q
                            control.setSpace( control.space === "local" ? "world" : "local" );
                            break;

                        case 87: // W
                            control.setMode( "translate" );
                            break;

                        case 69: // E
                            control.setMode( "rotate" );
                            break;

                        case 82: // R
                            control.setMode( "scale" );
                            break;

                        case 67: // C
                            const position = currentCamera.position.clone();

                            currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
                            currentCamera.position.copy( position );

                            orbit.object = currentCamera;
                            control.camera = currentCamera;

                            currentCamera.lookAt( orbit.target.x, orbit.target.y, orbit.target.z );
                            onWindowResize();
                            break;

                        case 86: // V
                            const randomFoV = Math.random() + 0.1;
                            const randomZoom = Math.random() + 0.1;

                            cameraPersp.fov = randomFoV * 160;
                            cameraOrtho.bottom = - randomFoV * 500;
                            cameraOrtho.top = randomFoV * 500;

                            cameraPersp.zoom = randomZoom * 5;
                            cameraOrtho.zoom = randomZoom * 5;
                            onWindowResize();
                            break;

                        case 187:
                        case 107: // +, =, num+
                            control.setSize( control.size + 0.1 );
                            break;

                        case 189:
                        case 109: // -, _, num-
                            control.setSize( Math.max( control.size - 0.1, 0.1 ) );
                            break;

                        case 88: // X
                            control.showX = ! control.showX;
                            break;

                        case 89: // Y
                            control.showY = ! control.showY;
                            break;

                        case 90: // Z
                            control.showZ = ! control.showZ;
                            break;

                        case 32: // Spacebar
                            control.enabled = ! control.enabled;
                            break;
                    }
                } );
            }

            function onWindowResize() {

                const aspect = window.innerWidth / window.innerHeight;

                cameraPersp.aspect = aspect;
                cameraPersp.updateProjectionMatrix();

                cameraOrtho.left = cameraOrtho.bottom * aspect;
                cameraOrtho.right = cameraOrtho.top * aspect;
                cameraOrtho.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                render();
            }

            function render() {
                if (window.mesh) {
                    let in_portal = window.plane;
                    let out_portal = window.plane2;

                    let mesh = window.mesh;
                    let linked_mesh = window.mesh2;

                    linked_mesh.matrixAutoUpdate  = false;
				
                    // Transforms to handle "in-out" behavior. For object going into A and out B:
                    // Flip Z: As you go in A, you come out B
                    // Flip X: Required to maintain right-hand rule.    
                    
                    //                       A                  B
                    //                           (+Y)    (+Y)
                    //                             |      |
                    //                             |      |
                    //                             |      |
                    //  OBJECT ->     (+Z) - - - - o      o - - - - (+Z)     -> OBJECT
                    //                            /        \
                    //                           /          \
                    //                        (+X)          (-X)

					var obj_to_in = new THREE.Matrix4();
					obj_to_in.multiplyMatrices(in_portal.matrixWorld.invert(), mesh.matrixWorld);

					var flip_xz = new THREE.Matrix4().identity();
					flip_xz.elements[0] *= -1;
					flip_xz.elements[10] *= -1;

                    let obj_to_out = new THREE.Matrix4().multiplyMatrices(flip_xz, obj_to_in);
                    linked_mesh.matrix.multiplyMatrices(out_portal.matrixWorld, obj_to_out);

					// Mesh.position isn't used when we turn auto-update to false.
					// If we want to keep it current, we need to manually set it from the matrix.
					linked_mesh.position.setFromMatrixPosition(linked_mesh.matrix);
                    linked_mesh.matrixWorldNeedsUpdate = true;
                }

                renderer.render( scene, currentCamera );

            }
            window.render = render;

        </script>
    </body>
</html>
